<?xml version="1.0"?>
<doc>
<assembly>
<name>
Microsoft.CodeAnalysis.VisualBasic.Workspaces
</name>
</assembly>
<members>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Classification.ClassificationHelpers.GetClassification(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Return the classification type associated with this token.
 </summary>
 <param name="token">The token to be classified.</param>
 <returns>The classification type for the token</returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Classification.ClassificationHelpers.IsControlKeywordKind(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Determine if the kind represents a control keyword
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Classification.ClassificationHelpers.IsControlStatementKind(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Determine if the kind represents a control statement
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Editing.VisualBasicImportAdder.ConflictWalker._importedTypesAndNamespaces">
 <summary>
 A mapping containing the simple names And arity of all namespace members, mapped to the import that
 they're brought in by.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Editing.VisualBasicImportAdder.ConflictWalker._importedMembers">
 <summary>
 A mapping containing the simple names of all members, mapped to the import that they're brought in by.
 Members are imported in through modules in vb. This doesn't keep track of arity because methods can be
 called with type arguments.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Editing.VisualBasicImportAdder.ConflictWalker._importedExtensionMethods">
 <summary>
 A mapping containing the simple names of all extension methods, mapped to the import that they're
 brought in by. This doesn't keep track of arity because methods can be called with type arguments.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Editing.VisualBasicImportAdder.ConflictWalker._inAnonymousMethod">
 <summary>
 Track if we're in an anonymous method or not.  If so, because of how the language binds lambdas and
 overloads, we'll assume any method access we see inside (instance or otherwise) could end up conflicting
 with an extension method we might pull in.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SemanticModelExtensions.GenerateNameForExpression(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Boolean,System.Threading.CancellationToken)">
 <summary>
 Given an expression node, tries to generate an appropriate name that can be used for
 that expression.
 </summary> 
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Extensions.DirectiveSyntaxExtensions.DirectiveInfo.StartEndMap">
 <summary>
 Returns a map which maps from a DirectiveTriviaSyntax to it's corresponding start/end directive.
 Directives like #ElseIf which exist in the middle of a start/end pair are not included.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.Extensions.DirectiveSyntaxExtensions.DirectiveInfo.ConditionalMap">
 <summary>
 Maps a #If/#ElseIf/#Else/#EndIf directive to its list of matching #If/#ElseIf/#Else/#End directives.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.DirectiveSyntaxExtensions.GetMatchingStartOrEndDirective(Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a starting or ending directive, return the matching directive, if it exists. For directives that live
 the "middle" of a start/end pair, such as #ElseIf or #Else, this method will throw.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.DirectiveSyntaxExtensions.GetMatchingConditionalDirectives(Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Threading.CancellationToken)">
 <summary>
 Given a conditional directive (#If, #ElseIf, #Else, or #End If), returns a IEnumerable of all directives in
 the set.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ExpressionSyntaxExtensions.DecomposeName(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax@,System.String@,System.Int32@)">
 <summary>
 Decompose a name or member access expression into its component parts.
 </summary>
 <param name="expression">The name or member access expression.</param>
 <param name="qualifier">The qualifier (or left-hand-side) of the name expression. This may be null if there is no qualifier.</param>
 <param name="name">The name of the expression.</param>
 <param name="arity">The number of generic type parameters.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions.SplitNodesOnPreprocessorBoundaries``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
 <summary>
 Breaks up the list of provided nodes, based on how they are 
 interspersed with pp directives, into groups.  Within these groups
 nodes can be moved around safely, without breaking any pp 
 constructs.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions.ContainsInterleavedDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
 <summary>
 Returns true if the passed in node contains an interleaved pp 
 directive.
 
 i.e. The following returns false:
 
   void Goo() {
 #if true
 #endif
   }
 
 #if true
   void Goo() {
   }
 #endif
 
 but these return true:
 
 #if true
   void Goo() {
 #endif
   }
 
   void Goo() {
 #if true
   }
 #endif
 
 #if true
   void Goo() {
 #else
   }
 #endif
 
 i.e. the method returns true if it contains a PP directive that 
 belongs to a grouping constructs (like #if/#endif or 
 #region/#endregion), but the grouping construct isn't entirely c
 contained within the span of the node.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions.IsExecutableBlock(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Returns true if this is a block that can contain multiple executable statements.  i.e.
 this node is the VB equivalent of a BlockSyntax in C#.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions.ChildThatContainsPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Int32@)">
 <summary>
 Returns child node or token that contains given position.
 </summary>
 <remarks>
 This is a copy of <see cref="M:Microsoft.CodeAnalysis.SyntaxNode.ChildThatContainsPosition(System.Int32)"/>  that also returns the index of the child node.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions.GetRootConditionalAccessExpression(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 <see cref="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFacts.GetRootConditionalAccessExpression(Microsoft.CodeAnalysis.SyntaxNode)"/>
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTokenExtensions.IsChildToken``1(Microsoft.CodeAnalysis.SyntaxToken,System.Func{``0,Microsoft.CodeAnalysis.SyntaxToken})">
 <summary>
 Returns true if is a given token is a child token of a certain type of parent node.
 </summary>
 <typeparam name="TParent">The type of the parent node.</typeparam>
 <param name="token">The token that we are testing.</param>
 <param name="childGetter">A function that, when given the parent node, returns the child token we are interested in.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTokenExtensions.IsChildSeparatorToken``2(Microsoft.CodeAnalysis.SyntaxToken,System.Func{``0,Microsoft.CodeAnalysis.SeparatedSyntaxList{``1}})">
 <summary>
 Returns true if is a given token is a separator token in a given parent list.
 </summary>
 <typeparam name="TParent">The type of the parent node containing the separated list.</typeparam>
 <param name="token">The token that we are testing.</param>
 <param name="childGetter">A function that, when given the parent node, returns the separated list.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTokenExtensions.IsFirstTokenOnLine(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Determines whether the given SyntaxToken is the first token on a line
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTreeExtensions.IsLastTokenOfStatementWithEndOfLine(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 check whether given token is the last token of a statement that ends with end of line trivia or an elastic trivia
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTreeExtensions.IsLastTokenOfStatement(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax@)">
 <summary>
 check whether given token is the last token of a statement by walking up the spine
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTreeExtensions.FindTriviaToLeft(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken)">
 <summary>
 Finds the token being touched by this position. Unlike the normal FindTrivia helper, this helper will prefer
 trivia to the left rather than the right if the position is on the border.
 </summary>
 <param name="syntaxTree">The syntaxTree to search.</param>
 <param name="position">The position to find trivia.</param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.IsStatementTerminatingTokenVisitor">
 <summary>
 A visitor that determines if the targetToken passed in the constructor can be considered
 the end of the visited statement. Tokens in the token stream of the file after
 targetToken are ignored. This means that in some cases, say "Throw" vs. "Throw x" there
 is more than one keyword that could terminate the statement.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTokenExtensions.HasNonContinuableEndOfLineBeforePosition(Microsoft.CodeAnalysis.SyntaxToken,System.Int32,System.Boolean)">
 <summary>
 We need to check for EOL trivia not preceded by LineContinuation trivia.
 
 This is slightly complicated since we need to get TrailingTrivia from missing tokens
 and then get LeadingTrivia for the next non-missing token.
 
 Note that this is even more complicated in the case that we're in structured trivia
 because we might be part of the leading trivia to the next non-missing token.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.IsTypeDeclarationContext(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
 <summary>
 The specified position is where we can declare some .NET type, such as classes, structures, etc.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.IsTypeMemberDeclarationKeywordContext(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
 <summary>
 The specified position is where a keyword can go like "Sub", "Function", etc. in a classes, structures, and modules
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.IsInterfaceMemberDeclarationKeywordContext(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
 <summary>
 The specified position is where a keyword can go like "Sub", "Function" in an interface
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.IsTypeDeclarationKeywordContext(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
 <summary>
 The specified position is where we can declare some .NET type, such as classes, structures, etc.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.IsSingleLineStatementContext(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
 <summary>
 The specified position is where I could start a statement in a place where exactly one
 statement could exist.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.IsMultiLineStatementStartContext(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
 <summary>
 The specified position is where I could start a statement in a place where one or more
 statements could exist.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.IsAfterStatementOfKind(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind[])">
 <summary>
 The specified position is immediately following a statement of one of the given kinds.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions.GetExpressionTerminatingToken(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Given a syntax node, this returns the token that is the "end" token that ends this
 expression.
 </summary>
 <param name="expression">The expression to get the last token of.</param>
 <returns>The last token, or SyntaxKind.None if the last token is missing.</returns>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.VisualBasicSyntaxContext">
 <summary>
 Helper structure to store some context about a position for keyword completion
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.VisualBasicSyntaxContext.FollowsEndOfStatement">
 <summary>
 True if position is after a colon, or an
 EOL that was not preceded by an explicit line continuation
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.VisualBasicSyntaxContext.MustBeginNewStatement">
 <summary>
 True if position is definitely the beginning of a new statement (after a colon
 or two line breaks).
 
 Dim q = From a In args
 $1
 $2
 
 $1 may continue the previous statement, but $2 definitely starts a 
 new statement since there are two line breaks before it.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.VisualBasicSyntaxTreeExtensions.IsAfterStatementOfKind(Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.VisualBasicSyntaxContext,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind[])">
 <summary>
 The specified position is immediately following a statement of one of the given kinds.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.IMethodSymbolExtensions.IsAggregateFunction(Microsoft.CodeAnalysis.IMethodSymbol)">
 <summary>
 Determines whether the given IMethodSymbol can be used as an aggregate function
 in a Group..By..Into or an Aggregate..Into clause.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxKindExtensions.Contains(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind[],Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 Determine if the given <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> array contains the given kind.
 </summary>
 <param name="kinds">Array to search</param>
 <param name="kind">Sought value</param>
 <returns>True if <paramref name="kinds"/> contains the value <paramref name="kind"/>.</returns>
 <remarks>PERF: Not using Array.IndexOf here because it results in a call to IndexOf on the default EqualityComparer for SyntaxKind. The default comparer for SyntaxKind is
 the ObjectEqualityComparer which results in boxing allocations.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxKindExtensions.IndexOf(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind[],Microsoft.CodeAnalysis.VisualBasic.SyntaxKind,System.Int32)">
 <summary>
 Locate the given <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind"/> in an array starting at the given index.
 </summary>
 <param name="kinds">Array to search</param>
 <param name="kind">Sought value</param>
 <param name="start">Starting index</param>
 <returns>The index of the first occurrence of <paramref name="kind"/> in <paramref name="kinds"/>.</returns>
 <remarks>PERF: Not using Array.IndexOf here because it results in a call to IndexOf on the default EqualityComparer for SyntaxKind. The default comparer for SyntaxKind is
 the ObjectEqualityComparer which results in boxing allocations.</remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.FindSymbols.VisualBasicDeclaredSymbolInfoFactoryService.GetSuffix(Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax)">
 <summary>
 Builds up the suffix to show for something with parameters in navigate-to.
 While it would be nice to just use the compiler SymbolDisplay API for this,
 it would be too expensive as it requires going back to Symbols (which requires
 creating compilations, etc.) in a perf sensitive area.
 
 So, instead, we just build a reasonable suffix using the pure syntax that a 
 user provided.  That means that if they wrote "Method(System.Int32 i)" we'll 
 show that as "Method(System.Int32)" Not "Method(Integer)".  Given that this Is
 actually what the user wrote, And it saves us from ever having to go back to
 symbols/compilations, this Is well worth it, even if it does mean we have to
 create our own 'symbol display' logic here.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Formatting.FormattingResult">
 <summary>
 this holds onto changes made by formatting engine.
 
 currently it only has an ability to apply those changes to buffer. but it could be expanded to
 support other cases as well such as tree or etc.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Formatting.TriviaDataFactory">
 <summary>
 trivia factory.
 
 it will cache some commonly used trivia to reduce memory footprint and heap allocation
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Formatting.TriviaDataFactory.ComplexTrivia">
 <summary>   
 represents a general trivia between two tokens. slightly more expensive than others since it
 needs to calculate stuff unlike other cases
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Formatting.TriviaDataFactory.LineContinuationTrivia">
 <summary>   
 represents a general trivia between two tokens. slightly more expensive than others since it
 needs to calculate stuff unlike other cases
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Recommendations.VisualBasicRecommendationServiceRunner.FilterEventsAndGeneratedSymbols(Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax,Microsoft.CodeAnalysis.ISymbol)">
 <summary>
 In MemberAccessExpression Contexts, filter out event symbols (except for NameOf context), except inside AddRemoveHandler Statements
 Also, filter out any implicitly declared members generated by event declaration or property declaration
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Rename.VisualBasicRenameRewriterLanguageService.RenameRewriter._isRenamingInStrings">
 <summary>
 Flag indicating if we should perform a rename inside string literals.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Rename.VisualBasicRenameRewriterLanguageService.RenameRewriter._isRenamingInComments">
 <summary>
 Flag indicating if we should perform a rename inside comment trivia.
 </summary>
</member>
<member name="F:Microsoft.CodeAnalysis.VisualBasic.Rename.VisualBasicRenameRewriterLanguageService.RenameRewriter._stringAndCommentTextSpans">
 <summary>
 A map from spans of tokens needing rename within strings or comments to an optional
 set of specific sub-spans within the token span that
 have <see cref="F:Microsoft.CodeAnalysis.VisualBasic.Rename.VisualBasicRenameRewriterLanguageService.RenameRewriter._originalText"/> matches and should be renamed.
 If this sorted set is Nothing, it indicates that sub-spans to rename within the token span
 are not available, and a regex match should be performed to rename
 all <see cref="F:Microsoft.CodeAnalysis.VisualBasic.Rename.VisualBasicRenameRewriterLanguageService.RenameRewriter._originalText"/> matches within the span.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Rename.VisualBasicRenameRewriterLanguageService.GetExpansionTargetForLocation(Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Gets the top most enclosing statement as target to call MakeExplicit on.
 It's either the enclosing statement, or if this statement is inside of a lambda expression, the enclosing
 statement of this lambda.
 </summary>
 <param name="token">The token to get the complexification target for.</param>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Rename.VisualBasicRenameRewriterLanguageService.GetSemanticModelForNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel)">
 <summary>
 Gets the semantic model for the given node. 
 If the node belongs to the syntax tree of the original semantic model, then returns originalSemanticModel.
 Otherwise, returns a speculative model.
 The assumption for the later case is that span start position of the given node in it's syntax tree is same as
 the span start of the original node in the original syntax tree.
 </summary>
 <param name="node"></param>
 <param name="originalSemanticModel"></param>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicInferredMemberNameReducer">
 <summary>
 Complexify makes inferred names explicit for tuple elements and anonymous type members. This
 class considers which ones of those can be simplified (after the refactoring was done).
 If the inferred name of the member matches, the explicit name (from Complexifiy) can be removed.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Simplification.Simplifiers.AbstractVisualBasicSimplifier`2.GetPredefinedKeywordKind(Microsoft.CodeAnalysis.SpecialType)">
 <summary>
 Returns the predefined keyword kind for a given special type.
 </summary>
 <param name="type">The specialtype of this type.</param>
 <returns>The keyword kind for a given special type, or SyntaxKind.None if the type name is not a predefined type.</returns>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Simplification.Simplifiers.AbstractVisualBasicSimplifier`2.IsInCrefReferenceForPredefinedTypeInMemberAccessContext(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <Remarks>
 Note: This helper exists solely to work around Bug 1012713. Once it is fixed, this helper must be
 deleted in favor of <see cref="M:Microsoft.CodeAnalysis.VisualBasic.Extensions.ExpressionSyntaxExtensions.InsideCrefReference(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)"/>.
 Context: Bug 1012713 makes it so that the compiler doesn't support <c>PredefinedType.Member</c> inside crefs 
 (i.e. System.Int32.MaxValue is supported but Integer.MaxValue isn't). Until this bug is fixed, we don't 
 support simplifying types names Like System.Int32.MaxValue to Integer.MaxValue.
 </Remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Simplification.Simplifiers.NameSimplifier.IsPartOfNamespaceDeclarationName(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 Checks if the SyntaxNode is a name of a namespace declaration. To be a namespace name, the syntax
 must be parented by an namespace declaration and the node itself must be equal to the declaration's Name
 property.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicSimplificationService.NodesAndTokensToReduceComputer.Compute(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.SyntaxNodeOrToken,System.Boolean})">
 <summary>
 Computes a list of nodes and tokens that need to be reduced in the given syntax root.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Utilities.SpeculationAnalyzer">
 <summary>
 Helper class to analyze the semantic effects of a speculated syntax node replacement on the parenting nodes.
 Given an expression node from a syntax tree and a new expression from a different syntax tree,
 it replaces the expression with the new expression to create a speculated syntax tree.
 It uses the original tree's semantic model to create a speculative semantic model and verifies that
 the syntax replacement doesn't break the semantics of any parenting nodes of the original expression.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Utilities.SpeculationAnalyzer.#ctor(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken,System.Boolean,System.Boolean)">
 <summary>
 Creates a semantic analyzer for speculative syntax replacement.
 </summary>
 <param name="expression">Original expression to be replaced.</param>
 <param name="newExpression">New expression to replace the original expression.</param>
 <param name="semanticModel">Semantic model of <paramref name="expression"/> node's syntax tree.</param>
 <param name="cancellationToken">Cancellation token.</param>
 <param name="skipVerificationForReplacedNode">
 True if semantic analysis should be skipped for the replaced node and performed starting from parent of the original and replaced nodes.
 This could be the case when custom verifications are required to be done by the caller or
 semantics of the replaced expression are different from the original expression.
 </param>
 <param name="failOnOverloadResolutionFailuresInOriginalCode">
 True if semantic analysis should fail when any of the invocation expression ancestors of <paramref name="expression"/> in original code has overload resolution failures.
 </param>        
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.Utilities.SpeculationAnalyzer.ReplacementChangesSemanticsOfUnchangedLambda(Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)">
 <summary>
 Determines whether performing the syntax replacement in one of the sibling nodes of the given lambda expressions will change the lambda binding semantics.
 This is done by first determining the lambda parameters whose type differs in the replaced lambda node.
 For each of these parameters, we find the descendant identifier name nodes in the lambda body and check if semantics of any of the parenting nodes of these
 identifier nodes have changed in the replaced lambda.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.Utilities.ModifierCollectionFacts">
 <summary>
 A helper class that is constructed giving a set of modifiers. It takes these modifiers, and
 breaks them down into separate categories, as well as determines what type of declaration is
 being forced if certain modifiers are present.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTreeFactoryServiceFactory.VisualBasicSyntaxTreeFactoryService.NullSyntaxReference">
 <summary>
 Represents a syntax reference that was passed a null
 reference to a node. In this case, we just hold onto the
 weak tree reference and throw if any invalid properties
 are accessed.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTreeFactoryServiceFactory.VisualBasicSyntaxTreeFactoryService.PathSyntaxReference">
 <summary>
 Represents a syntax reference that doesn't actually hold onto the 
 referenced node.  Instead, enough data is held onto so that the node
 can be recovered and returned if necessary.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTreeFactoryServiceFactory.VisualBasicSyntaxTreeFactoryService.PositionalSyntaxReference">
 <summary>
 Represents a syntax reference that doesn't actually hold onto the referenced node.
 Instead, enough data is held onto so that the node can be recovered and returned if
 necessary.
 </summary>
</member>
<member name="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTreeFactoryServiceFactory.VisualBasicSyntaxTreeFactoryService.RecoverableSyntaxTree">
 <summary>
 Represents a syntax tree that only has a weak reference to its 
 underlying data.  This way it can be passed around without forcing
 the underlying full tree to stay alive.  Think of it more as a 
 key that can be used to identify a tree rather than the tree itself.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSymbolDeclarationService.GetDeclarations(Microsoft.CodeAnalysis.ISymbol)">
 <summary>
 Get the declaring syntax node for a Symbol. Unlike the DeclaringSyntaxReferences property,
 this function always returns a block syntax, if there is one.
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSymbolDeclarationService.GetBlockFromBegin(Microsoft.CodeAnalysis.SyntaxNode)">
 <summary>
 If "node" is the begin statement of a declaration block, return that block, otherwise
 return node.
 </summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Namespace_can_not_be_added_in_this_destination">
 <summary>Namespace can not be added in this destination.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Only_attributes_expressions_or_statements_can_be_made_explicit">
 <summary>Only attributes, expressions or statements can be made explicit</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.event_">
 <summary>&lt;event&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.handler">
 <summary>&lt;handler&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.The_expression_to_be_evaluated_and_converted">
 <summary>The expression to be evaluated and converted.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.The_name_of_the_data_type_to_which_the_value_of_expression_will_be_converted">
 <summary>The name of the data type to which the value of expression will be converted.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.expression">
 <summary>&lt;expression&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.typeName">
 <summary>&lt;typeName&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Associates_an_event_with_an_event_handler_delegate_or_lambda_expression_at_run_time">
 <summary>Associates an event with an event handler, delegate or lambda expression at run time.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.The_event_to_associate_an_event_handler_delegate_or_lambda_expression_with">
 <summary>The event to associate an event handler, delegate or lambda expression with.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.The_event_handler_to_associate_with_the_event_This_may_take_the_form_of_AddressOf_eventHandler_delegate_lambdaExpression">
 <summary>The event handler to associate with the event. This may take the form of { AddressOf &lt;eventHandler&gt; | &lt;delegate&gt; | &lt;lambdaExpression&gt; }.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.If_expression_evaluates_to_a_reference_or_Nullable_value_that_is_not_Nothing_the_function_returns_that_value_Otherwise_it_calculates_and_returns_expressionIfNothing">
 <summary>If &lt;expression&gt; evaluates to a reference or Nullable value that is not Nothing, the function returns that value. Otherwise, it calculates and returns &lt;expressionIfNothing&gt;.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Returned_if_it_evaluates_to_a_reference_or_nullable_type_that_is_not_Nothing">
 <summary>Returned if it evaluates to a reference or nullable type that is not Nothing.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Evaluated_and_returned_if_expression_evaluates_to_Nothing">
 <summary>Evaluated and returned if &lt;expression&gt; evaluates to Nothing.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.expressionIfNothing">
 <summary>&lt;expressionIfNothing&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Returns_the_result_of_explicitly_converting_an_expression_to_a_specified_data_type">
 <summary>Returns the result of explicitly converting an expression to a specified data type.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Introduces_a_type_conversion_operation_similar_to_CType_The_difference_is_that_CType_succeeds_as_long_as_there_is_a_valid_conversion_whereas_DirectCast_requires_that_one_type_inherit_from_or_implement_the_other_type">
 <summary>Introduces a type conversion operation similar to CType. The difference is that CType succeeds as long as there is a valid conversion, whereas DirectCast requires that one type inherit from or implement the other type.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.The_type_name_to_return_a_System_Type_object_for">
 <summary>The type name to return a System.Type object for.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Returns_a_System_Type_object_for_the_specified_type_name">
 <summary>Returns a System.Type object for the specified type name.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.The_XML_namespace_prefix_to_return_a_System_Xml_Linq_XNamespace_object_for_If_this_is_omitted_the_object_for_the_default_XML_namespace_is_returned">
 <summary>The XML namespace prefix to return a System.Xml.Linq.XNamespace object for. If this is omitted, the object for the default XML namespace is returned.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.xmlNamespacePrefix">
 <summary>&lt;xmlNamespacePrefix&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Returns_the_System_Xml_Linq_XNamespace_object_corresponding_to_the_specified_XML_namespace_prefix">
 <summary>Returns the System.Xml.Linq.XNamespace object corresponding to the specified XML namespace prefix.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Replaces_a_specified_number_of_characters_in_a_String_variable_with_characters_from_another_string">
 <summary>Replaces a specified number of characters in a String variable with characters from another string.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.The_name_of_the_string_variable_to_modify">
 <summary>The name of the string variable to modify.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.The_one_based_character_position_in_the_string_where_the_replacement_of_text_begins">
 <summary>The one-based character position in the string where the replacement of text begins.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.The_number_of_characters_to_replace_If_omitted_the_length_of_stringExpression_is_used">
 <summary>The number of characters to replace. If omitted, the length of &lt;stringExpression&gt; is used.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.stringName">
 <summary>&lt;stringName&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.startIndex">
 <summary>&lt;startIndex&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.length">
 <summary>&lt;length&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.stringExpression">
 <summary>&lt;stringExpression&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Converts_an_expression_to_the_0_data_type">
 <summary>Converts an expression to the {0} data type.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Removes_the_association_between_an_event_and_an_event_handler_or_delegate_at_run_time">
 <summary>Removes the association between an event and an event handler or delegate at run time.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.The_event_to_disassociate_an_event_handler_or_delegate_from">
 <summary>The event to disassociate an event handler or delegate from.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.The_event_handler_to_disassociate_from_the_event_This_may_take_the_form_of_AddressOf_eventHandler_delegate">
 <summary>The event handler to disassociate from the event. This may take the form of { AddressOf &lt;eventHandler&gt; | &lt;delegate&gt; }.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.If_condition_returns_True_the_function_calculates_and_returns_expressionIfTrue_Otherwise_it_returns_expressionIfFalse">
 <summary>If &lt;condition&gt; returns True, the function calculates and returns &lt;expressionIfTrue&gt;. Otherwise, it returns &lt;expressionIfFalse&gt;.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.The_expression_to_evaluate">
 <summary>The expression to evaluate.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Evaluated_and_returned_if_condition_evaluates_to_True">
 <summary>Evaluated and returned if &lt;condition&gt; evaluates to True.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Evaluated_and_returned_if_condition_evaluates_to_False">
 <summary>Evaluated and returned if &lt;condition&gt; evaluates to False.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.condition">
 <summary>&lt;condition&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.expressionIfTrue">
 <summary>&lt;expressionIfTrue&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.expressionIfFalse">
 <summary>&lt;expressionIfFalse&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Introduces_a_type_conversion_operation_that_does_not_throw_an_exception_If_an_attempted_conversion_fails_TryCast_returns_Nothing_which_your_program_can_test_for">
 <summary>Introduces a type conversion operation that does not throw an exception. If an attempted conversion fails, TryCast returns Nothing, which your program can test for.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Node_does_not_descend_from_root">
 <summary>Node does not descend from root.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Node_not_in_parent_s_child_list">
 <summary>Node not in parent's child list</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Trivia_is_not_associated_with_token">
 <summary>Trivia is not associated with token</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.typeOrMember">
 <summary>&lt;typeOrMember&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.The_type_of_member_to_return_the_name_of">
 <summary>The type of member to return the name of.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Produces_a_string_for_the_name_of_the_specified_type_or_member">
 <summary>Produces a string for the name of the specified type or member.</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.result">
 <summary>&lt;result&gt;</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Remove_and_Sort_Imports">
 <summary>R&amp;emove and Sort Imports</summary>
</member>
<member name="P:Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources.Sort_Imports">
 <summary>&amp;Sort Imports</summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.FixIncorrectTokensCodeCleanupProvider.FixIncorrectTokensRewriter.RewriteEndIfStatementOrDirectiveSyntax(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
 <summary>
 Rewrite "EndIf" to "End If" for an EndIfStatementSyntax/EndIfDirectiveSyntax node.
 </summary>
 <param name="curNode">Syntax node for the EndIfStatementSyntax or EndIfDirectiveSyntax to be rewritten.</param>
 <param name="curEndKeyword">"End" keyword token for <paramref name="curNode"/>.</param>
 <param name="curIfKeyword">"If" keyword token for <paramref name="curNode"/>.</param>
 <returns>Rewritten EndIfStatementSyntax/EndIfDirectiveSyntax node.</returns>
 <remarks>
 This method checks for the following:
 (a) Both the End keyword and If keyword, <paramref name="curEndKeyword"/> and <paramref name="curIfKeyword"/> respectively, are Missing tokens AND
 (b) Descendant Trivia under the given <paramref name="curEndKeyword"/> token or <paramref name="curIfKeyword"/> token has an "EndIf" keyword token.
 
 If the above conditions are met, it does the following node rewrites:
 (a) Replace the missing <paramref name="curEndKeyword"/> and <paramref name="curIfKeyword"/> tokens with new "End" and "If" keywords tokens respectively.
 (b) Remove the first "EndIf" keyword token from the descendant trivia and adjust the leading and trailing trivia appropriately.
 </remarks>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.OperatorStatementSpecialFixup(Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax)">
 <summary>
 this will put operator token and modifier tokens in right order
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.ValidOperatorStatement(Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax)">
 <summary>
 check whether given operator statement is valid or not
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.NormalizeOperator(Microsoft.CodeAnalysis.SyntaxToken,System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Boolean},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTriviaList},System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.List{Microsoft.CodeAnalysis.VisualBasic.SyntaxKind}},System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Int32,Microsoft.CodeAnalysis.SyntaxToken})">
 <summary>
 normalize operator
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.ReorderModifiers(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 reorder modifiers in the list
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.NormalizeModifiers``1(``0,Microsoft.CodeAnalysis.SyntaxNode,System.Func{``0,Microsoft.CodeAnalysis.SyntaxTokenList},System.Func{``0,Microsoft.CodeAnalysis.SyntaxTokenList,``0})">
 <summary>
 normalize modifier list of the node and record changes if there is any change
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.NormalizeModifiers``1(``0,``0,System.Func{``0,Microsoft.CodeAnalysis.SyntaxTokenList},System.Func{``0,Microsoft.CodeAnalysis.SyntaxTokenList,``0})">
 <summary>
 normalize modifier list of the node and record changes if there is any change
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.RemoveDimKeyword``1(``0,System.Func{``0,Microsoft.CodeAnalysis.SyntaxTokenList})">
 <summary>
 remove "Dim" keyword if present
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.RemoveModifierKeyword``1(``0,System.Func{``0,Microsoft.CodeAnalysis.SyntaxTokenList},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)">
 <summary>
 remove a modifier from the given node
 </summary>
</member>
<member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider.Rewriter.AreModifiersInRightOrder(Microsoft.CodeAnalysis.SyntaxTokenList)">
 <summary>
 check whether given modifiers are in right order (in sync with ModifierKindsInOrder list)
 </summary>
</member>
<member name="P:VisualBasicCompilerExtensionsResources.EmptyResource">
 <summary>Remove this value when another is added.</summary>
</member>
<member name="P:VisualBasicWorkspaceExtensionsResources.EmptyResource">
 <summary>Remove this value when another is added.</summary>
</member>
</members>
</doc>
